name: 🚀 DevOps Excellence CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - production

env:
  TERRAFORM_VERSION: '1.5.0'
  KUBECTL_VERSION: 'v1.28.0'
  HELM_VERSION: 'v3.12.0'
  PYTHON_VERSION: '3.11'
  GO_VERSION: '1.21'
  NODE_VERSION: '18'

jobs:
  # Security and Code Quality Checks
  security-scan:
    name: 🔒 Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Checkov static analysis
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: terraform,kubernetes,dockerfile
          output_format: sarif
          output_file_path: checkov-report.sarif

      - name: Upload Checkov scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: checkov-report.sarif

  # Code Quality and Linting
  code-quality:
    name: 🧹 Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install pre-commit
        run: pip install pre-commit

      - name: Run pre-commit hooks
        run: pre-commit run --all-files

      - name: Lint Python code
        run: |
          pip install flake8 black isort
          find . -name "*.py" -exec flake8 {} \;
          find . -name "*.py" -exec black --check {} \;
          find . -name "*.py" -exec isort --check-only {} \;

      - name: Lint Go code
        run: |
          go install golang.org/x/lint/golint@latest
          find . -name "*.go" -exec golint {} \;
          find . -name "*.go" -exec go vet {} \;

      - name: Validate YAML files
        run: |
          pip install yamllint
          find . -name "*.yaml" -o -name "*.yml" | xargs yamllint

  # Terraform Validation and Planning
  terraform:
    name: 🏗️ Terraform
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [dev, staging, production]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Terraform Format Check
        run: terraform fmt -check -recursive infrastructure/

      - name: Terraform Init
        run: |
          cd infrastructure/terraform/environments/${{ matrix.environment }}
          terraform init

      - name: Terraform Validate
        run: |
          cd infrastructure/terraform/environments/${{ matrix.environment }}
          terraform validate

      - name: Terraform Plan
        run: |
          cd infrastructure/terraform/environments/${{ matrix.environment }}
          terraform plan -out=tfplan

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v3
        with:
          name: terraform-plan-${{ matrix.environment }}
          path: infrastructure/terraform/environments/${{ matrix.environment }}/tfplan

  # Kubernetes Manifests Validation
  kubernetes:
    name: ☸️ Kubernetes
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Validate Kubernetes manifests
        run: |
          find kubernetes/ -name "*.yaml" -exec kubectl apply --dry-run=client --validate=true -f {} \;

      - name: Lint Helm charts
        run: |
          find infrastructure/helm/charts/ -maxdepth 1 -mindepth 1 -type d -exec helm lint {} \;

      - name: Validate Helm charts
        run: |
          find infrastructure/helm/charts/ -maxdepth 1 -mindepth 1 -type d | while read chart; do
            helm template test "$chart" --values "$chart/values.yaml" > /dev/null
          done

  # Build and Test Applications
  build-test:
    name: 🔨 Build & Test
    runs-on: ubuntu-latest
    needs: [security-scan, code-quality]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Python applications
        run: |
          find automation/python -name "requirements.txt" -exec pip install -r {} \;
          find automation/python -name "*.py" -exec python -m py_compile {} \;

      - name: Test Python applications
        run: |
          if [ -f automation/python/requirements-test.txt ]; then
            pip install -r automation/python/requirements-test.txt
            python -m pytest automation/python/tests/ -v
          fi

      - name: Build Go applications
        run: |
          find automation/go -name "go.mod" -execdir go build ./... \;

      - name: Test Go applications
        run: |
          find automation/go -name "go.mod" -execdir go test ./... -v \;

      - name: Build Docker images
        run: |
          find . -name "Dockerfile" | while read dockerfile; do
            dir=$(dirname "$dockerfile")
            echo "Building Docker image in $dir"
            docker build -t test-image:latest "$dir"
          done

  # Infrastructure Tests
  infrastructure-tests:
    name: 🧪 Infrastructure Tests
    runs-on: ubuntu-latest
    needs: [terraform]
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Install Terratest dependencies
        run: |
          cd tests/infrastructure
          go mod download

      - name: Run Terratest
        run: |
          cd tests/infrastructure
          go test -v -timeout 30m

  # Deploy to Development
  deploy-dev:
    name: 🚀 Deploy to Development
    runs-on: ubuntu-latest
    needs: [build-test, terraform, kubernetes]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment: development
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan-dev
          path: infrastructure/terraform/environments/dev/

      - name: Terraform Apply
        run: |
          cd infrastructure/terraform/environments/dev
          terraform init
          terraform apply tfplan

      - name: Deploy applications
        run: |
          # Configure kubectl
          aws eks update-kubeconfig --region us-west-2 --name dev-cluster
          
          # Deploy using kubectl
          find kubernetes/base -name "*.yaml" -exec kubectl apply -f {} \;

  # Deploy to Staging
  deploy-staging:
    name: 🎭 Deploy to Staging
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2

      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan-staging
          path: infrastructure/terraform/environments/staging/

      - name: Terraform Apply
        run: |
          cd infrastructure/terraform/environments/staging
          terraform init
          terraform apply tfplan

      - name: Run smoke tests
        run: |
          # Run post-deployment smoke tests
          if [ -f scripts/smoke-tests.sh ]; then
            ./scripts/smoke-tests.sh staging
          fi

  # Deploy to Production
  deploy-production:
    name: 🏭 Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-west-2

      - name: Download Terraform Plan
        uses: actions/download-artifact@v3
        with:
          name: terraform-plan-production
          path: infrastructure/terraform/environments/production/

      - name: Terraform Apply
        run: |
          cd infrastructure/terraform/environments/production
          terraform init
          terraform apply tfplan

      - name: Post-deployment verification
        run: |
          # Run comprehensive post-deployment tests
          if [ -f scripts/production-tests.sh ]; then
            ./scripts/production-tests.sh
          fi

      - name: Notify deployment
        uses: 8398a7/action-slack@v3
        if: always()
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          text: |
            Production deployment ${{ job.status }}!
            Commit: ${{ github.sha }}
            Author: ${{ github.actor }}

  # Cleanup
  cleanup:
    name: 🧹 Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-dev, deploy-staging, deploy-production]
    if: always()
    steps:
      - name: Clean up artifacts
        uses: geekyeggo/delete-artifact@v2
        with:
          name: |
            terraform-plan-dev
            terraform-plan-staging
            terraform-plan-production
